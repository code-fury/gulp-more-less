{
  "name": "homunculus",
  "version": "0.7.8",
  "description": "A lexer&parser by Javascript",
  "maintainers": [
    {
      "name": "army8735",
      "email": "army8735@qq.com"
    }
  ],
  "scripts": {
    "test": "make test"
  },
  "config": {
    "blanket": {
      "pattern": [
        "src/lexer/Lexer",
        "src/lexer/CssLexer",
        "src/lexer/HtmlLexer",
        "src/lexer/Token",
        "src/lexer/match",
        "src/lexer/rule/Rule",
        "src/lexer/rule/EcmascriptRule",
        "src/lexer/rule/CssRule",
        "src/lexer/rule/HtmlRule",
        "src/parser",
        "src/util/walk"
      ]
    }
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/army8735/homunculus.git"
  },
  "keywords": [
    "lexer",
    "parser",
    "javascript",
    "html",
    "css",
    "es5",
    "es6"
  ],
  "author": {
    "name": "army8735"
  },
  "license": "MIT",
  "dependencies": {},
  "main": "./index",
  "spm": {
    "main": "./index"
  },
  "engines": {
    "node": ">= 0.10.0"
  },
  "readmeFilename": "README.md",
  "devDependencies": {
    "blanket": "^1.1.6",
    "coveralls": "^2.10.0",
    "expect.js": "^0.3.1",
    "gulp": "^3.8.1",
    "gulp-clean": "^0.2.4",
    "gulp-util": "^2.2.14",
    "mocha": "^1.18.2",
    "mocha-lcov-reporter": "0.0.1",
    "through2": "^0.4.2",
    "unicode-7.0.0": "^0.1.5"
  },
  "readme": "# A lexer&parser by Javascript\n\n`homunculus`取自`钢之炼金术师`中的`人造人`，英语亦作`小矮人`，意指底层基石再造。\n\n[![NPM version](https://badge.fury.io/js/homunculus.png)](https://npmjs.org/package/homunculus)\n[![Build Status](https://travis-ci.org/army8735/homunculus.svg?branch=master)](https://travis-ci.org/army8735/homunculus)\n[![Coverage Status](https://coveralls.io/repos/army8735/homunculus/badge.png)](https://coveralls.io/r/army8735/homunculus)\n[![Dependency Status](https://david-dm.org/army8735/homunculus.png)](https://david-dm.org/army8735/homunculus)\n\n## INSTALL\n```\nnpm install homunculus\n```\n\n## 使用说明\n* 解析语法并返回语法树和此法单元序列。\n* CommonJS/AMD/CMD自适应。\n\n## API\n### Homunculus\n* getClass(type:String, lan:String):class\n  * type:\n    * lexer \n    * parser\n    * node\n    * context\n    * token\n    * rule\n    * walk\n  * lan: \n    * js\n    * javascript\n    * es \n    * es5\n    * ecmascript\n    * es6\n    * as\n    * actionscript\n    * css\n    * html\n    * htm\n* getLexer(lan:String):lexer/Lexer\n * lan:\n   * js\n   * javascript\n   * es\n   * es5\n   * ecmascript\n   * es6\n   * as\n   * actionscript\n   * css\n   * java\n   * c++\n   * cpp\n   * cplusplus\n    * html\n    * htm\n* getParser(lan:String):parser/Parser\n  * lan:\n    * js\n    * javascript\n    * es\n    * es5\n    * ecmascript\n    * es6\n    * css\n    * html\n    * htm\n* getContext(lan:String):parser/Context\n  * lan:\n    * js\n    * javascript\n    * es\n    * es5\n    * ecmascript\n* reset():void 重置Token的tid\n\n### lexer/Lexer\n#### 方法\n* constructor(Rule:lexer/rule/Rule) 传入语法规则Rule\n* parse(code:String):Array<lexer/Token> 传入代码并返回解析后的此法单元token列表\n* tokens(plainObject:Boolean = false):Array<lexer/Token> 返回已解析好的此番单元token列表，如果plainObject为true则传回普通对象\n* cache(line:init):void 设置缓冲解析行，每次最多解析几行代码，防止code过大卡死\n* finish():Boolean 设置cache有用，当前是否解析完毕\n* line():int code有多少行\n* col():int code最大列是多少\n\n#### 静态属性\n* STRICT: 0 严格模式语法错误后抛出异常\n* LOOSE: 1 宽松模式错误后忽略\n* mod(type:int):int 读取/设置模式\n\n### parser/Parser\n#### 方法\n* constructor(lexer:Lexer) 传入词法分析器\n* parse(code:String):Node 传入代码解析并返回语法树\n* ast(plainObject:Boolean = false):Node 返回已解析好的语法树，如果plainObject为true则传回普通对象\n* ignore():Object 返回解析中被忽略掉的空白注释等内容\n\n### lexer/Token\n#### 方法\n* constructor(type:int, content:String, val:String, sIndex:int) 构造函数传入token的类型、内容、字面内容和在代码中的开始字符索引\n* type(t:int):int 读取/设置类型\n* content(c:Stirng):String 读取/设置内容\n* val(v:String):String 读取/设置字面内容，字面内容不同于内容之处在于是否包含引号\n* tag(t:int):String 读取/设置类型，返回的是类型额字符串形式\n* tid(t:int):int 读取/设置token索引，默认所有token自增形式添加索引\n* sIndex(i:int):int 读取/设置token在code中的字符索引\n* isVirtual():Boolean 返回此token是否是虚拟不存在的\n\n#### 静态属性\n* type(t:int):String 返回类型的字符串形式\n* reset():Void 重置tid\n\n### parser/Node\n#### 方法\n* constructor(type:String, children:Node/Array<Node> = null) 传入类型和子节点\n* name(t:String):String 读取/设置节点类型\n* leaves():Array<Node> 返回子节点列表\n* leaf(i:int):Node 返回第i个子节点\n* size():int 返回有几个子节点\n* first():Node 返回第一个子节点\n* last():Node 返回最后一个子节点\n* isEmpty():Boolean 返回是否没有子节点\n* add(...node:Node):void 添加若干个子节点\n* token():Token 实际同leaves()一样，不过当name()为Token时children存储的是终结符Token\n* isToken():Boolean 返回此节点是否是Token节点\n* parent():Node 返回父节点\n* prev():Node 返回兄弟前一个节点\n* next():Node 返回兄弟后一个节点\n\n### lexer/rule/Rule\n#### 方法\n* constructor(keyWords:Array<String>, supportPerlReg:Boolean = false) 关键字列表和是否支持perl风格的正则表达式\n* addKeyWord(kw:String):Object 添加未知关键字并返回关键字hash，仅限此次对象分析\n\n### util/walk\n#### 方法\n* simple(node:Node, nodeVisitors:Object, tokenVisitors:Object) 遍历语法树工具。nodeVisitors以树节点名做键，回调做值，回调参数为树节点；tokenVisitors以token类型做键，回调做值，回调参数为token\n* simpleIgnore(node:Node, ignore:Object, nodeVisitors:Object, tokenVisitors:Object) 同上，增加第2个参数为忽略掉的空白符等。tokenVisitors的回调增加第2个参数为此token后面的忽略的token数组\n* recursion(node:Node, callback:Function) 递归工具，深度遍历语法树，回调每个节点。回调参数第1个为节点或者token，第2个参数标明是否是token\n* plainObject(node:Node):Array 序列化语法树结果为普通类型\n* plainObject(tokens:Array<Token>):Array 序列化tokens结果为普通类型\n\n#### 特别的，对于css还可以设置添加属性和颜色别名\n* addValue(v:String):Object 添加未知属性并返回属性hash，仅限此次对象分析\n* addColor(c:String):Object 添加未知颜色并返回颜色hash，仅限此次对象分析\n\n#### 亦可使用静态方法统一添加关键字等，一劳永逸\n* addKeyWord(kw:String):Array<String>\n* addValue(v:String):Array<String>\n* addColor(c:String):Array<String>\n\n## AST\n当调用语法分析器解析后，会返回生成ast，这是一个树状数据结构，每个节点都是对应语法解析器目录下的Node.js的实例。<br/>\ndemo目录下是一个用js的parser分析输入js代码并画出ast形状的页面。<br/>\n你也可以在线尝试它：http://army8735.me/homunculus\n\n## License\n[MIT License]",
  "bugs": {
    "url": "https://github.com/army8735/homunculus/issues"
  },
  "_id": "homunculus@0.7.8",
  "dist": {
    "shasum": "6e275662377b9c2dc100bf2a846276555c78b6d0"
  },
  "_from": "homunculus@^0.7.7",
  "_resolved": "https://registry.npmjs.org/homunculus/-/homunculus-0.7.8.tgz"
}
